# SW 공학 (Software Engineering)

## CI/CD (Continuous Integration / Continuous Delivery & Deployment)

**한줄설명:** 코드를 자동으로 빌드, 테스트, 배포하는 파이프라인

**상세설명:**
- 소프트웨어 개발에서 지속적 통합과 지속적 배포를 통해 개발 생산성을 높이는 기법
- 개발자가 코드를 푸시하면 자동으로 빌드, 테스트, 배포 단계를 거치는 자동화 파이프라인
- 버그를 조기에 발견하고 배포 주기를 단축시킴

**리뷰:** 현대 소프트웨어 개발의 필수 요소이며, DevOps 문화의 기반. 클라우드 환경과 함께 기본 운영 아키텍처 구성

---

## 빌드 (Build)

**한줄설명:** 소스코드를 실행 가능한 형태로 변환하고 배포 가능한 형태로 가공하는 과정

**상세설명:**
- 소스코드는 사람이 이해하는 형태이고, 기계가 이해할 수 있는 형태로 바꾸는 과정
- 빌드는 단순 변환만 하는 게 아니라 여러 작업의 묶음:
  - 컴파일: 소스코드를 기계어로 변환
  - 패키징: 필요한 파일들을 패키지로 묶음
  - 번들링: 모듈들을 하나로 묶음
  - 압축/최적화: 파일 크기 최소화
  - 의존성 설치: 필요한 라이브러리 설치

**리뷰:** 빌드 자동화는 CI/CD 파이프라인의 첫 번째 단계로 매우 중요

---

## 컨테이너 (Container)

**한줄설명:** 애플리케이션과 그 실행환경을 패키지로 묶어서 어디서든 동일하게 실행되게 하는 기술

**상세설명:**
- 필요한 소스코드, 필요한 라이브러리, OS환경을 독립적인 공간에 담아서 실행
- 특징:
  - Dockerfile로 자동화 가능
  - 높은 이식성: 다양한 환경에서 동일하게 실행
  - 빠른 실행 속도
  - 높은 격리성: 다른 프로세스와 독립적으로 동작
- 기존 방식(각 서버에 직접 설치)의 문제를 해결:
  - 서버 환경이 다르면 실행에 문제 발생 가능
  - 배포 복잡성 증가
- 클라우드 + 컨테이너가 기본 운영 아키텍처

**리뷰:** 현대 서버 운영의 표준 기술이며, 마이크로서비스 아키텍처의 기반

---

## 도커 (Docker)

**한줄설명:** 컨테이너를 관리하고 활성화해주는 도구

**상세설명:**
- 컨테이너 기술의 가장 널리 사용되는 플랫폼
- 이미지로부터 컨테이너를 생성, 실행, 관리
- Dockerfile을 통해 이미지 빌드 자동화

**리뷰:** 컨테이너 기술의 사실상 표준. 대부분의 DevOps 환경에서 필수

---

## 클래스 다이어그램 (UML - Unified Modeling Language)

**한줄설명:** 소프트웨어 설계를 시각화하는 다이어그램

**상세설명:**
- UML의 한 종류로 클래스 구조를 나타냄
- 클래스 간의 관계(상속, 포함, 의존성 등)를 표현
- 객체 지향 설계 단계에서 주로 사용

**리뷰:** 팀 프로젝트에서 설계 문서로 사용되며, 코드 구조를 이해하는 데 유용

---

## 4+1 View (아키텍처 뷰)

**한줄설명:** 소프트웨어 아키텍처를 4개의 뷰와 유스케이스로 표현하는 방법

**상세설명:**
- 논리적 뷰 (Logical View): 기능적 요구사항
- 개발 뷰 (Development View): 소프트웨어 구조
- 프로세스 뷰 (Process View): 런타임 동작
- 물리적 뷰 (Physical View): 배포 구조
- 유스케이스 (Use Cases): 시스템 기능

**리뷰:** 대규모 시스템 설계 시 여러 관점에서 아키텍처를 이해하는 데 도움

---

## 추상 클래스 (Abstract Class)

**한줄설명:** 인스턴스화할 수 없고 상속을 통해서만 사용되는 클래스

**상세설명:**
- 일반적인 인터페이스와 공통 기능을 정의
- 구체적인 구현은 자식 클래스에서 담당
- 메서드를 abstract로 선언하여 반드시 오버라이드하도록 강제

**리뷰:** 객체 지향 설계에서 계층 구조를 만들 때 중요한 개념

---

## 디자인 패턴 (Design Pattern)

**한줄설명:** 개발하면서 발생하는 문제들을 해결하기 위한 설계 방식들을 정리한 템플릿

**상세설명:**
- 재사용 가능한 해결 방안들을 패턴으로 정리
- 3가지 유형:
  1. **생성 패턴 (Creational)**: 객체 생성 방식
     - Singleton, Factory, Builder 등
  2. **구조 패턴 (Structural)**: 객체와 클래스 조합
     - Adapter, Bridge, Composite 등
  3. **행위 패턴 (Behavioral)**: 객체 간 상호작용
     - Observer, Strategy, Command 등
- 각 유형별 하나씩은 꼭 알아두기
- 실제 프로젝트에서 사용해본 경험이 중요

**리뷰:** 면접에서 자주 나오는 주제. "이 상황에 어떤 패턴을 사용했는가?"라는 질문 대비 필수

---

## GoF (Gang of Four)

**한줄설명:** 디자인 패턴 분류의 기초를 제시한 4명의 저자

**상세설명:**
- 1994년 "Design Patterns: Elements of Reusable Object-Oriented Software" 출판
- 23개의 디자인 패턴을 체계적으로 분류
- 현재도 가장 널리 인정되는 분류 방식

**리뷰:** GoF 패턴은 업계 표준이며, 이를 기반으로 학습하는 것이 중요

---

## 유닛 테스트 (Unit Test)

**한줄설명:** 소프트웨어의 가장 작은 단위(함수, 클래스 등)를 대상으로 올바르게 작동하는지 검증

**상세설명:**
- 개별 함수나 메서드의 동작 검증
- 버그를 조기에 발견
- 리팩토링 시 기존 기능이 깨지지 않았는지 확인
- 테스트 자동화로 생산성 향상

**리뷰:** 전문 개발자의 필수 스킬. TDD(Test-Driven Development) 기반 개발 추세

---

## 통합 테스트 (Integration Test)

**한줄설명:** 둘 이상의 유닛(모듈)의 상호작용을 테스트하여 연결이 잘 되어있는지 확인

**상세설명:**
- 여러 모듈이 함께 작동하는지 검증
- DB 연결, API 호출 등 외부 시스템과의 상호작용 포함
- 유닛 테스트보다 복잡하고 느림

**리뷰:** 시스템 전체 기능이 제대로 작동하는지 확인하는 중요한 단계

---

## 시스템 테스트 (System Test)

**한줄설명:** 전체 시스템이 요구사항에 맞게 작동하는지 확인

**상세설명:**
- 통합된 전체 시스템의 기능성, 성능, 보안 등 검증
- 사용자 관점에서의 기능 확인
- 가장 높은 수준의 테스트

**리뷰:** QA(Quality Assurance) 팀에서 주로 담당

---

## 인수 테스트 (Acceptance Test)

**한줄설명:** 완성된 제품을 실제 사용자 입장에서 테스트

**상세설명:**
- 최종 사용자 또는 클라이언트가 수행
- 비즈니스 요구사항 충족 여부 확인
- UAT(User Acceptance Test)라고도 불림
- 배포 전 최종 검증 단계

**리뷰:** 고객 만족도를 결정하는 중요한 단계

---

## 객체 지향 프로그래밍 (OOP - Object-Oriented Programming)

**한줄설명:** 현실세계를 모방하여 객체와 메서드를 하나로 묶어서 프로그래밍하는 방식

**상세설명:**
- 핵심 개념:
  - **클래스**: 객체의 설계도
  - **객체**: 클래스의 인스턴스
  - **캡슐화**: 데이터와 메서드를 하나로 묶고 외부 접근 제한
  - **상속**: 기존 클래스의 기능을 이어받아 새로운 클래스 정의
  - **다형성**: 같은 메서드가 객체 타입에 따라 다르게 동작
- 문제점: 객체마다 공통적으로 필요로 하는 기능(횡단 관심사)을 어떻게 처리할 것인가?
  → AOP(Aspect Oriented Programming)로 해결

**리뷰:** 현대 프로그래밍의 기본 패러다임. SOLID 원칙과 함께 꼭 이해해야 함

---

## SOLID 원칙 (5가지 객체 지향 설계 원칙)

### 1. SRP (Single Responsibility Principle) - 단일 책임의 원칙

**한줄설명:** 하나의 클래스는 하나의 책임만 가져야 함

**상세설명:**
- 클래스는 오직 하나의 이유로만 수정되어야 함
- 하나의 클래스가 여러 가지 기능을 하고 있으면 SRP 위반
- 예: 사용자 정보, 데이터베이스 접근, 로깅을 모두 처리하는 클래스 → 역할 분리 필요

**리뷰:** 유지보수성과 테스트 용이성을 높이는 기본 원칙

---

### 2. OCP (Open Closed Principle) - 개방 폐쇄의 원칙

**한줄설명:** 확장에는 열려있어야 하고, 수정에는 닫혀있어야 함

**상세설명:**
- 새로운 기능을 추가할 때 기존 코드를 수정하지 않고 확장 가능해야 함
- 구현 방식:
  - 추상 클래스나 인터페이스를 정의
  - 상속하여 새로운 기능 추가
- 예: 결제 방식이 추가될 때 기존 코드는 변경하지 않고 새로운 결제 클래스만 추가

**리뷰:** 유연하고 확장 가능한 코드 설계의 핵심

---

### 3. LSP (Liskov Substitution Principle) - 리스코프 치환 원칙

**한줄설명:** 자식클래스는 언제나 부모 클래스의 자리를 대체할 수 있어야 함

**상세설명:**
- 부모 클래스의 메서드를 오버라이드한 자식 클래스가 기대되는 동작을 유지해야 함
- 위반 예: 직사각형 클래스를 상속한 정사각형 클래스가 너비와 높이를 다르게 설정하면 LSP 위반
- 상속 관계가 IS-A 관계를 정확히 나타내는지 확인 필요

**리뷰:** 상속 설계 시 매우 중요한 원칙

---

### 4. ISP (Interface Segregation Principle) - 인터페이스 분리 원칙

**한줄설명:** 클라이언트는 자신이 사용하지 않는 인터페이스에 의존하면 안 됨

**상세설명:**
- 하나의 인터페이스가 너무 많은 기능을 담고 있으면 분리해야 함
- 클라이언트는 필요한 기능만 구현할 수 있도록 작게 쪼갠 인터페이스가 좋음
- 예: 동물 인터페이스가 fly(), swim(), walk()를 모두 포함하면 비행 불가능한 동물은?
  → 각 기능별로 별도의 인터페이스로 분리

**리뷰:** 불필요한 의존성을 제거하여 코드 복잡도 감소

---

### 5. DIP (Dependency Inversion Principle) - 의존 역전 원칙

**한줄설명:** 상위 모듈은 하위 모듈에 의존하면 안 되고, 둘 다 추상화된 인터페이스에 의존해야 함

**상세설명:**
- 고수준 모듈이 저수준 모듈에 직접 의존하면 안 됨
- 대신 추상 인터페이스에 의존하여 유연함 증대
- 느슨한 결합(Loose Coupling) 달성
- 예: 결제 모듈이 신용카드 결제 클래스에 직접 의존 → 결제 인터페이스를 중간에 두고 의존

**리뷰:** 유지보수성과 테스트 용이성을 크게 향상시키는 원칙

---

## AOP (Aspect Oriented Programming) - 관점 지향 프로그래밍

**한줄설명:** 객체 지향 프로그래밍의 한계를 보완하는 프로그래밍 패러다임

**상세설명:**
- OOP의 문제점(횡단 관심사)을 해결하는 방법
- 로깅, 보안, 트랜잭션 처리 등 여러 모듈에서 공통으로 필요한 기능을 분리
- Aspect: 여러 객체에 공통으로 적용되는 기능
- 구현: 데코레이터, Spring AOP 등을 통해 구현

**리뷰:** Spring 프레임워크에서 많이 사용되며, 엔터프라이즈 개발에서 필수적인 개념
